using System;
using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Fengb3.EasyCodeBuilder.Csharp;
using Fengb3.EasyCodeBuilder.Csharp.OptionConfigurations;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Fengb3.EasyCodeBuilder.Csharp.Code;

namespace CodeBuilder.Demo.SourceGenerator;

[Generator]
public class BuilderSourceGenerator : IIncrementalGenerator
{
    private const string Namespace                  = "CodeBuilder.Demo.SourceGenerator.Attributes";
    private const string AttributeHintName          = "BuilderAttributes.g.cs";
    public const  string BuilderAttributeName       = "Builder";
    public const  string BuilderIgnoreAttributeName = "BuilderIgnore";

    public const string FullBuilderAttributeName       = Namespace + "." + BuilderAttributeName;
    public const string FullBuilderIgnoreAttributeName = Namespace + "." + BuilderIgnoreAttributeName;

    private readonly string AttributeSourceCode =
        Create()
            .AppendLine("// <auto-generated/>")
            .Namespace(ns => {
                    ns.WithName(Namespace);

                    ns.AppendLine("[System.AttributeUsage(System.AttributeTargets.Class)]");
                    ns.Public.Class(cls => cls
                        .WithName("Builder")
                        .Inherit("System.Attribute")
                    );

                    ns.AppendLine("[System.AttributeUsage(System.AttributeTargets.Property)]");
                    ns.Public.Class(cls => cls
                        .WithName("BuilderIgnore")
                        .Inherit("System.Attribute")
                    );
                }
            ).Build();
    
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx
            .AddSource(AttributeHintName, SourceText.From(AttributeSourceCode, Encoding.UTF8))
        );

        // get all classes with [Builder] attribute
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.builderAttributeFound)
            .Select((t, _) => t.Item1);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            ((ctx, t) => GenerateCode(ctx, t.Left, t.Right)));
    }

    private void GenerateCode(SourceProductionContext ctx, Compilation arg2Left, ImmutableArray<ClassDeclarationSyntax> arg2Right)
    {
        foreach (var classDeclarationSyntax in arg2Right)
        {
            var semanticModel = arg2Left.GetSemanticModel(classDeclarationSyntax.SyntaxTree);
            var classSymbol   = semanticModel.GetDeclaredSymbol(classDeclarationSyntax);
            if (classSymbol is null)
            {
                continue;
            }

            var className = classSymbol.Name;
            // 获取完整的命名空间名称
            var nsName             = classSymbol.ContainingNamespace.ToDisplayString();
            var generatedClassName = className + "Builder";

            Action<TypeOption> configClass = builderClass => builderClass
                .WithName(generatedClassName)
                .Public.Readonly.Field(@field => @field
                    .WithName("_instance")
                    .WithType(className)
                    .WithInitializer($"new {className}()")
                )
                .Public.Method(mtd => mtd
                    .WithName("Build")
                    .WithReturnType(className)
                    .AppendLine($"return _instance;")
                );

            // get property declarations
            foreach (var member in classDeclarationSyntax.Members)
            {
                if (member is not PropertyDeclarationSyntax propertyDeclarationSyntax)
                    continue;

                // skip properties with [BuilderIgnore] attribute
                var hasIgnoreAttribute = false;
                foreach (var attributeList in propertyDeclarationSyntax.AttributeLists)
                {
                    foreach (var attribute in attributeList.Attributes)
                    {
                        var symbolInfo = ModelExtensions.GetSymbolInfo(arg2Left.GetSemanticModel(propertyDeclarationSyntax.SyntaxTree), attribute);
                        if (symbolInfo.Symbol is IMethodSymbol methodSymbol)
                        {
                            var attributeName = methodSymbol.ContainingType.ToDisplayString();
                            if (attributeName == FullBuilderIgnoreAttributeName)
                            {
                                hasIgnoreAttribute = true;
                                break;
                            }
                        }
                    }
                    if (hasIgnoreAttribute)
                        break;
                }

                // skip none public properties
                var modifiers = propertyDeclarationSyntax.Modifiers;

                if (hasIgnoreAttribute || !modifiers.Any(SyntaxKind.PublicKeyword))
                    continue;

                var propertyName = propertyDeclarationSyntax.Identifier.Text;
                var propertyType = propertyDeclarationSyntax.Type.ToString();

                configClass += builderClass => builderClass
                    .Public.Method(mth => mth
                        .WithName($"With{propertyName}")
                        .WithParameters($"{propertyType} {propertyName.ToLower()}")
                        .WithReturnType(generatedClassName)
                        .AppendLine($"_instance.{propertyName} = {propertyName.ToLower()};")
                        .AppendLine("return this;")
                    );
            }

            var source = Create()
                .AppendLine("//<auto-generated/>")
                .Namespace(ns => ns
                    .WithName(nsName)
                    .Public.Class(configClass)
                ).Build();

            // Add the source code to the compilation.
            ctx.AddSource($"{generatedClassName}.g.cs", source);
        }
    }

    private (Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax, bool builderAttributeFound) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)context.Node;

        var builderAttributeFound = false;

        foreach (var attributeList in classDeclarationSyntax.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbolInfo = ModelExtensions.GetSymbolInfo(context.SemanticModel, attribute);
                if (symbolInfo.Symbol is IMethodSymbol methodSymbol)
                {
                    var attributeName = methodSymbol.ContainingType.ToDisplayString();

                    if (attributeName == FullBuilderAttributeName)
                    {
                        builderAttributeFound = true;
                    }
                }
            }
        }

        return (classDeclarationSyntax, builderAttributeFound);
    }
}